options {
    LOOKAHEAD=8;
    UNICODE_INPUT=true;
}

PARSER_BEGIN(Lexer)

package com.hugovs.jps;

import java.util.List;
import java.util.ArrayList;
import java.util.Stack;
import java.io.*;
import com.hugovs.jps.structure.semanthic.*;
import com.hugovs.jps.structure.exception.*;

public class Lexer {

    public static Block program = new Block();
    public static int blockCount = 0;
    public static Stack<Block> stack = new Stack<Block>();

    public static void main(String[] args) {
        try {
            new Lexer(new java.io.FileInputStream(args[0])).S();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}

PARSER_END(Lexer)

SKIP: {" " | "\t" | "\n" | "\r" | < "//" (~["\r", "\n"])* > }

TOKEN: {
      <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <LBRACK: "[">
    | <RBRACK: "]">
    | <COMMA: ",">
    | <COLON: ":">
    | <SEMICOLON: ";">
    | <EQ: "=">
    | <OP: "+" | "-" | "/" | "*" | "%">
    | <BOP: "==" | "<" | ">" | "<=" | ">=">

    // Restricted
    | <DEF: "def">
    | <VAR: "var">
    | <TYPE: "int" | "bool" | "string" >
    | <BOOL: "true" | "false">

    // Commands
    | <CMD_IF: "if">
    | <CMD_ELSE: "else">
    | <CMD_FOR: "for">
    | <CMD_WHILE: "while">
    | <CMD_READ: "read">
    | <CMD_WRITE: "write">
    | <CMD_STOP: "stop">
    | <CMD_SKIP: "skip">
    | <CMD_RETURN: "return">

    // Util
    | <ID: <CHAR> (<CHAR> | <NUM>)* >

    // Primitives
    | <STR: ["\""] (<CHAR> | <NUM> | " ")* ["\""]>
    | <CHAR: ["a"-"z"] | ["A"-"Z"] | ["_"]>
    | <NUM: (["0"-"9"])+>
}

// Regra inicial
void S():           {} { PROGRAM() <EOF> }

// Regra do programa
void PROGRAM():
    {
        Block program = Lexer.program;
        Block block = null;
    }{(
        block = ROOT_BLOCK()
    ){
        program = block;
    }}

// Regra de Sub-Programa
Subprogram SUB_PROGRAM():
    {
        Subprogram subprogram = new Subprogram();
        Block block, parent = Lexer.stack.peek();
        Token typeToken = null, idToken = null;
        List<Variable> parameters = new ArrayList<Variable>();
    }{(
        <DEF> idToken = <ID> <LPAREN> (parameters = PARAMETERS())? <RPAREN> (<COLON> typeToken = <TYPE>)? block = BLOCK()
    ){

        String id = idToken.toString();
        Type returnType = typeToken == null ? Type.VOID : Type.valueOf(typeToken.toString().toUpperCase());

        block.setParent(parent);
        subprogram.setId(id);
        subprogram.setReturnType(returnType);
        subprogram.setBlock(block);
        subprogram.setParameters(parameters);
        block.getParent().addIdentifier(subprogram);

        return subprogram;

    }}

// Bloco inicial do programa
Block ROOT_BLOCK():
    {
        Block block = new Block();
        Lexer.stack.push(block);
        List<Variable> varList = null;
    }{(
        (varList = VAR_SECTION())? (EXPRESSION())?
    ){

        if (varList != null) {
            block.addAll(varList);
        }

        System.out.println("Identifiers found in block " + Lexer.blockCount + ": ");
        for (Identifier i : block.getIdentifiers().values())
            System.out.println("  " + i.toString());

        Lexer.stack.pop();
        return block;
    }}

// Blocos internos no programa
Block BLOCK():
    {
        Lexer.blockCount++;
        Block block = new Block();
        Lexer.stack.push(block);
        List<Variable> varList = null;
    }{(
        <LBRACE> (varList = VAR_SECTION())? (EXPRESSION())? <RBRACE>
    ){

        if (varList != null)
            block.addAll(varList);

        Lexer.stack.pop();
        return block;
    }}

//void SUB_PROGRAM_CALL(): {} { }

void EXPRESSION():
    {
        Subprogram sub;
    }{(
        sub = SUB_PROGRAM() <SEMICOLON> (EXPRESSION())?//|   SUB_PROGRAM_CALL()
    ){

    }}

// Command syntax
void CMD():         {} { CMD_IF() | CMD_FOR() | CMD_WHILE() | CMD_READ() | CMD_WRITE() | CMD_STOP() | CMD_SKIP() | CMD_RETURN() | CMD_SUB() | CMD_RETURN() }
void CMD_IF():      {} { <CMD_IF> <LPAREN> EXP() <RPAREN> BLOCK() (CMD_ELSE())? }
void CMD_ELSE():    {} { <CMD_ELSE> (CMD_IF() | BLOCK()) }
void CMD_FOR():     {} { <CMD_FOR> <LPAREN> VAR() <SEMICOLON> EXP() <SEMICOLON> VAR_LIST() }
void CMD_WHILE():   {} { <CMD_WHILE> <LPAREN> EXP() <RPAREN> }
void CMD_READ():    {} { <CMD_READ> <ID> }
void CMD_WRITE():   {} { <CMD_WRITE> EXP() }
void CMD_STOP():    {} { <CMD_STOP> }
void CMD_SKIP():    {} { <CMD_SKIP> }
void CMD_RETURN():  {} { <CMD_RETURN> EXP() }
void CMD_SUB():     {} { <ID> <LPAREN> (EXP() (<SEMICOLON> EXP())*)? <RPAREN> }

void EXP():         {} { VALUE() ((<OP> | <BOP>) VALUE())* }

// Regra base para declaração de umaou mais variáveis
List<Variable> VAR():
    {
        List<Variable> varList;
        Token typeToken;
    }{(
        <VAR> varList = VAR_LIST() <COLON> typeToken = <TYPE>
    ){
        Type type = Type.valueOf(typeToken.toString().toUpperCase());
        Util.updateVariableTypes(varList, type);

        return varList;
    }}

// Lista de variáveis
List<Variable> VAR_LIST():
    {
        List<Variable> varList = new ArrayList<Variable>(), ret = new ArrayList<Variable>();
        Variable var = new Variable();
        Token idToken, lengthToken = null;
        boolean isArray = false;
    }{(

        idToken = <ID> <LBRACK> ( lengthToken = <NUM>)? <RBRACK> (<COMMA> ret = VAR_LIST())? { isArray = true; }
    |   idToken = <ID> (<COMMA> ret = VAR_LIST())?

    ){
        String id = idToken.toString();

        if (lengthToken != null) {
            var.setLength(Integer.valueOf(lengthToken.toString()));
        }

        var.setId(id);
        var.setArray(isArray);
        varList.addAll(ret);
        varList.add(var);
        return varList;
    }}

// Seção de variáveis separadas por ponto e vírgula
List<Variable> VAR_SECTION():
    {
        List<Variable> varList = null, ret = null;
    }{(
        (varList = VAR() <SEMICOLON> (ret = VAR_SECTION())?)
    ){
        if (ret != null)
            varList.addAll(ret);
        return varList;
    }}

// Regra de definição de parâmetros de sub-programa
List<Variable> PARAMETERS():
        {
            List<Variable> varList, v2 = null;
            Token typeToken;
        }{(
            varList = PARAM_LIST() <COLON> typeToken = <TYPE> (<SEMICOLON> v2 = PARAMETERS())?
        ){

            Type type = Type.valueOf(typeToken.toString().toUpperCase());
            Util.updateVariableTypes(varList, type);

            if (v2 != null)
                varList.addAll(v2);

            return varList;
        }}

List<Variable> PARAM_LIST():
    {
        List<Variable> varList = new ArrayList<Variable>(), ret = new ArrayList<Variable>();
        Variable var = new Variable();
        Token idToken;
        boolean isArray = false;
    }{(

        idToken = <ID> <LBRACK> <RBRACK> (<COMMA> ret = PARAM_LIST())? { isArray = true; }
    |   idToken = <ID> (<COMMA> ret = PARAM_LIST())?

    ){
        String id = idToken.toString();

        var.setId(id);
        var.setArray(isArray);
        varList.addAll(ret);
        varList.add(var);
        return varList;
    }}

void VALUE():       {} { CMD_SUB() | <NUM> | <ID>}
