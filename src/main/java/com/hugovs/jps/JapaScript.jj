options {
    LOOKAHEAD=2;
}

PARSER_BEGIN(Lexer)

public class Lexer {

    public static void main(String[] args) {
        try {
            new Lexer(new java.io.FileInputStream(args[0])).S();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}

PARSER_END(Lexer)

SKIP: {" " | "\t" | "\n" | "\r" | < "//" (~["\r", "\n"])* > }

TOKEN: {
      <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <LBRACK: "[">
    | <RBRACK: "]">
    | <COMMA: ",">
    | <COLON: ":">
    | <SEMICOLON: ";">
    | <EQ: "=">
    | <OP: "+" | "-" | "/" | "*" | "%">
    | <BOP: "==" | "<" | ">" | "<=" | ">=">

    // Restricted
    | <DEF: "def">
    | <VAR: "var">
    | <TYPE: "int" | "bool" | "string" >
    | <BOOL: "true" | "false">

    // Commands
    | <CMD_IF: "if">
    | <CMD_ELSE: "else">
    | <CMD_FOR: "for">
    | <CMD_WHILE: "while">
    | <CMD_READ: "read">
    | <CMD_WRITE: "write">
    | <CMD_STOP: "stop">
    | <CMD_SKIP: "skip">
    | <CMD_RETURN: "return">

    // Util
    | <ID: <CHAR> (<CHAR> | <NUM>)* >
    | <ARRAY_DEF: <LBRACK> <NUM> <RBRACK>>
    | <ARRAY_DEC: <LBRACK><RBRACK>>

    // Primitives
    | <STR: ["\""] (<CHAR> | <NUM> | " ")* ["\""]>
    | <CHAR: ["a"-"z"] | ["A"-"Z"] | ["_"]>
    | <NUM: (["0"-"9"])+>
}

void S():           {} { PROGRAM() <EOF> }
Program PROGRAM():  { Program program = new Program(); }
    {
        (VAR() <SEMICOLON> )* (SUBPROGRAM())*
    }

void SUBPROGRAM():  {} { <DEF> <ID> <LPAREN> (VARARG())? <RPAREN> <COLON> <TYPE> SCOPE() }
void SCOPE():       {} { <LBRACE> (VAR() <SEMICOLON> )* (SUBPROGRAM() | CMD())* <RBRACE> }

// Command syntax
void CMD():         {} { (CMD_IF() | CMD_FOR() | CMD_WHILE() | CMD_READ() | CMD_WRITE() | CMD_STOP() | CMD_SKIP() | CMD_RETURN() | CMD_SUB()) }
void CMD_IF():      {} { <CMD_IF> <LPAREN> EXP() <RPAREN> SCOPE() (CMD_ELSE())? }
void CMD_ELSE():    {} { <CMD_ELSE> ((CMD_IF())? | SCOPE()) }
void CMD_FOR():     {} { <CMD_FOR> <LPAREN> VAR() <SEMICOLON> EXP() <SEMICOLON> VARARG() }
void CMD_WHILE():   {} { <CMD_WHILE> <LPAREN> EXP() <RPAREN> }
void CMD_READ():    {} { <CMD_READ> <ID> }
void CMD_WRITE():   {} { <CMD_WRITE> EXP() }
void CMD_STOP():    {} { <CMD_STOP> }
void CMD_SKIP():    {} { <CMD_SKIP> }
void CMD_RETURN():  {} { <CMD_RETURN> EXP() }
void CMD_SUB():     {} { <ID> <LPAREN> (EXP() (<SEMICOLON> EXP())*)? <RPAREN> }

void EXP():         {} { VALUE() ((<OP> | <BOP>) VALUE())* }

// Variable syntax
void VAR():         {} { <VAR> VARARG() }
void VARARG():      {} { ID() (<COMMA> ID())* <COLON> <TYPE> }

void ID():
    {
        Identifier id = new Identifier();
    }
    {
          id.name = <ID> id.data = ATTRIBUTION()
        | id.name = <ID> (<ARRAY_DEF> | <ARRAY_DEC>)
        | <ID>

    }

void ATTRIBUTION(): {} { (<OP>)? <EQ> (<NUM> | <BOOL> | <STR>) }

void VALUE():       {} { CMD_SUB() | <NUM> | <ID>}
