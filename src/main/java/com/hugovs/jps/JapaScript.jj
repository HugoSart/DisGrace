options {
    LOOKAHEAD=8;
    UNICODE_INPUT=true;
}

PARSER_BEGIN(Lexer)

package com.hugovs.jps;

import java.util.List;
import java.util.ArrayList;
import java.util.Stack;
import java.io.*;
import com.hugovs.jps.structure.semanthic.*;
import com.hugovs.jps.structure.semanthic.command.*;
import com.hugovs.jps.structure.semanthic.operation.*;
import com.hugovs.jps.structure.semanthic.operation.bool.*;
import com.hugovs.jps.structure.semanthic.operation.compare.*;
import com.hugovs.jps.structure.semanthic.operation.integer.*;
import com.hugovs.jps.structure.semanthic.operation.string.*;
import com.hugovs.jps.structure.exception.*;

public class Lexer {

    public static Block program = new Block();
    public static int blockCount = 0;
    public static Stack<Block> stack = new Stack<Block>();

    public static void main(String[] args) {
        try {
            new Lexer(new java.io.FileInputStream(args[0])).S();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}

PARSER_END(Lexer)

SKIP: {" " | "\t" | "\n" | "\r" | < "//" (~["\r", "\n"])* > }

TOKEN: {
      <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <LBRACK: "[">
    | <RBRACK: "]">
    | <COMMA: ",">
    | <COLON: ":">
    | <SEMICOLON: ";">
    | <ATTR: "=">
    | <OP: "+" | "-" | "/" | "*" | "%">
    | <COP: "<" | ">" | "<=" | ">=" | "==" | "!=">
    | <BOP: "!" | "&&" | "||" >

    // Restricted
    | <DEF: "def">
    | <VAR: "var">
    | <TYPE: "int" | "bool" | "string" >
    | <BOOL: "true" | "false">

    // Commands
    | <CMD_IF: "if">
    | <CMD_ELSE: "else">
    | <CMD_FOR: "for">
    | <CMD_WHILE: "while">
    | <CMD_READ: "read">
    | <CMD_WRITE: "write">
    | <CMD_STOP: "stop">
    | <CMD_SKIP: "skip">
    | <CMD_RETURN: "return">

    // Util
    | <ID: <CHAR> (<CHAR> | <NUM>)* >

    // Primitives
    | <STR: ["\""] (<CHAR> | <NUM> | " ")* ["\""]>
    | <CHAR: ["a"-"z"] | ["A"-"Z"] | ["_"]>
    | <NUM: (["0"-"9"])+>
}

// Regra inicial
void S():
    {

    }{(
        PROGRAM() <EOF>
    ){

    }}

// Regra do programa
void PROGRAM():
    {
        Block program = Lexer.program;
        Block block = null;
    }{(
        block = ROOT_BLOCK()
    ){
        program = block;
    }}

// Regra de Sub-Programa
Subprogram SUB_PROGRAM():
    {
        Subprogram subprogram = new Subprogram();
        Block block, parent = Lexer.stack.peek();
        Token typeToken = null, idToken = null;
        List<Variable> parameters = new ArrayList<Variable>();
    }{(
        <DEF> idToken = <ID> <LPAREN> (parameters = PARAMETERS())? <RPAREN> (<COLON> typeToken = <TYPE>)? block = BLOCK(parameters)
    ){

        String id = idToken.toString();
        Type returnType = typeToken == null ? Type.VOID : Type.valueOf(typeToken.toString().toUpperCase());

        subprogram.setId(id);
        subprogram.setReturnType(returnType);
        subprogram.setBlock(block);
        subprogram.setParameters(parameters);

        block.getParent().addIdentifier(subprogram);

        for (Command cmd : block.getCommands())
            if (cmd instanceof ReturnCommand) {
                ReturnCommand returnCmd = (ReturnCommand)cmd;
                if (returnCmd.getExpression().getType() != subprogram.getReturnType())
                    throw new IncompatibleTypeException(returnCmd.getExpression().getType(), subprogram.getReturnType());
            }

        return subprogram;

    }}

// Bloco inicial do programa
Block ROOT_BLOCK():
    {
        Block block = new Block();
        Lexer.stack.push(block);
        List<Variable> varList = null;
    }{(
        (varList = VAR_SECTION() { block.addAll(varList); })? (STATEMENT())?
    ){

        System.out.println("Identifiers found in block " + Lexer.blockCount + ": ");
        for (Identifier i : block.getIdentifiers().values())
            System.out.println("  " + i.toString());

        Lexer.stack.pop();
        return block;
    }}

// Blocos internos no programa
Block BLOCK(List<Variable> parameters):
    {
        Lexer.blockCount++;
        Block block = new Block();
        block.setParent(Lexer.stack.peek());
        block.addAll(parameters);
        Lexer.stack.push(block);
        List<Variable> varList = null;
    }{(
        <LBRACE> (varList = VAR_SECTION() {block.addAll(varList);} )? (STATEMENT())? <RBRACE>
    ){

        Lexer.stack.pop();
        return block;
    }}

//void SUB_PROGRAM_CALL(): {} { }

void STATEMENT():
    {
        Block block = Lexer.stack.peek();
        Subprogram sub = null;
        Command cmd = null;
    }{(
        (sub = SUB_PROGRAM() | cmd = CMD())  <SEMICOLON> (STATEMENT())?//|   SUB_PROGRAM_CALL()
    ){
        if (cmd != null)
            block.addCommand(cmd);
    }}

// Command syntax
Command CMD():
    {
        Command cmd = null;
    }{(
        cmd = CMD_RETURN() | cmd = CMD_SUB()
        //cmd = CMD_IF() | cmd = CMD_FOR() | cmd = CMD_WHILE() | cmd = CMD_READ() | cmd = CMD_WRITE() |
        //cmd = CMD_STOP() | cmd = CMD_SKIP() | cmd = CMD_RETURN()
    ){
        return cmd;
    }}

Command CMD_RETURN():
    {
        ReturnCommand cmd = new ReturnCommand();
        Expression exp = new Expression();
        exp.setType(Type.VOID);
    }{(
        <CMD_RETURN> (exp = EXPRESSION())?
    ){
        cmd.setExpression(exp);
        return cmd;
    }}

Command CMD_SUB():
    {
        SubCommand cmd = new SubCommand();
    }{(
        <ID> <LPAREN> (EXPRESSION() (<SEMICOLON> EXPRESSION())*)? <RPAREN>
    ){
        return cmd;
    }}

/*Command CMD_IF():
    {
        IfCommand cmd = new IfCommand();
    }{(
        <CMD_IF> <LPAREN> EXP() <RPAREN> BLOCK() (CMD_ELSE())?
    ){

    }}*/

//Command CMD_ELSE():    {} { <CMD_ELSE> (CMD_IF() | BLOCK()) }
//Command CMD_FOR():     {} { <CMD_FOR> <LPAREN> VAR() <SEMICOLON> EXP() <SEMICOLON> VAR_LIST() }
//Command CMD_WHILE():   {} { <CMD_WHILE> <LPAREN> EXP() <RPAREN> }
//Command CMD_READ():    {} { <CMD_READ> <ID> }
//Command CMD_WRITE():   {} { <CMD_WRITE> EXP() }
//Command CMD_STOP():    {} { <CMD_STOP> }
//Command CMD_SKIP():    {} { <CMD_SKIP> }

Expression EXPRESSION():
    {
        Expression exp = new Expression();
        Value v = null;
        Operation op = null;
    }{(
        op = OPERATION() | v = VALUE()
    ){

        if (v != null) {
            exp.setSingleton(true);
            exp.setType(v.getType());
            exp.setValue(v);
        } else if (op != null) {
            exp.setSingleton(false);
            exp.setType(op.getType());
            exp.addOperation(op);
        }

        return exp;

    }}

// Regra base para declaração de umaou mais variáveis
List<Variable> VAR():
    {
        List<Variable> varList;
        Token typeToken;
    }{(
        <VAR> varList = VAR_LIST() <COLON> typeToken = <TYPE>
    ){
        Type type = Type.valueOf(typeToken.toString().toUpperCase());
        Util.updateVariableTypes(varList, type);

        return varList;
    }}

// Lista de variáveis
List<Variable> VAR_LIST():
    {
        List<Variable> varList = new ArrayList<Variable>(), ret = new ArrayList<Variable>();
        Variable var = new Variable();
        Token idToken;
        Expression arrayExp = null, attrExp = null;
        boolean isArray = false;
    }{(

        idToken = <ID> <LBRACK> arrayExp = EXPRESSION() <RBRACK> (<COMMA> ret = VAR_LIST())? { isArray = true; }
    |   idToken = <ID> (<ATTR> attrExp = EXPRESSION())? (<COMMA> ret = VAR_LIST())?

    ){
        String id = idToken.toString();

        if (arrayExp != null && arrayExp.getType() != Type.INT)
            throw new IncompatibleTypeException(Type.INT, arrayExp.getType());

        if (attrExp != null)
            var.setValue(attrExp);

        var.setId(id);
        var.setArray(isArray);
        var.setLength(Integer.MAX_VALUE); //TODO: Dar um jeito aqui
        varList.addAll(ret);
        varList.add(var);
        return varList;
    }}

// Seção de variáveis separadas por ponto e vírgula
List<Variable> VAR_SECTION():
    {
        List<Variable> varList = null, ret = null;
    }{(
        (varList = VAR() <SEMICOLON> (ret = VAR_SECTION())?)
    ){
        if (ret != null)
            varList.addAll(ret);
        return varList;
    }}

// Regra de definição de parâmetros de sub-programa
List<Variable> PARAMETERS():
        {
            List<Variable> varList, v2 = null;
            Token typeToken;
        }{(
            varList = PARAM_LIST() <COLON> typeToken = <TYPE> (<SEMICOLON> v2 = PARAMETERS())?
        ){

            Type type = Type.valueOf(typeToken.toString().toUpperCase());
            Util.updateVariableTypes(varList, type);

            if (v2 != null)
                varList.addAll(v2);

            return varList;
        }}

List<Variable> PARAM_LIST():
    {
        List<Variable> varList = new ArrayList<Variable>(), ret = new ArrayList<Variable>();
        Variable var = new Variable();
        Token idToken;
        boolean isArray = false;
    }{(

        idToken = <ID> <LBRACK> <RBRACK> (<COMMA> ret = PARAM_LIST())? { isArray = true; }
    |   idToken = <ID> (<COMMA> ret = PARAM_LIST())?

    ){
        String id = idToken.toString();

        var.setId(id);
        var.setArray(isArray);
        var.setLength(Integer.MAX_VALUE);
        var.setValue(new Value());
        varList.addAll(ret);
        varList.add(var);
        return varList;
    }}

Value VALUE():
    {
        Token idToken = null, numToken = null, boolToken = null, strToken = null;
        Block block = Lexer.stack.peek();
        Value value = new Value();
    }{(
        numToken = <NUM> | boolToken = <BOOL> | strToken = <STR> | idToken = <ID> <LBRACK> numToken = <NUM> <RBRACK> | idToken = <ID>
    ){

        Type type = null;

        Integer num = null;
        if (numToken != null && idToken == null) {
            num = Integer.valueOf(numToken.toString());
            value.setValue(num);
            type = Type.INT;
        }

        Boolean bool = null;
        if (boolToken != null) {
            bool = Boolean.valueOf(boolToken.toString());
            value.setValue(bool);
            type = Type.BOOL;
        }

        String str = null;
        if (strToken != null) {
            str = strToken.toString();
            value.setValue(str);
            type = Type.STRING;
        }

        Identifier id = null;
        if (idToken != null) {
            id = block.getIdentifier(idToken.toString());
            if (id instanceof Variable) {
                Variable var = ((Variable) id);
                type = var.getType();
                if (numToken != null) {
                    if (!var.isArray()) throw new IncompatibleTypeException("Variable " + id + " is not an array");
                    num = Integer.valueOf(numToken.toString());
                    if (num >= var.getLength()) throw new InvalidArraySizeException(num);
                } else if (var.isArray()) {
                    throw new IncompatibleTypeException("Variable " + id + " is an array");
                }

                if (!var.isInitialized())
                    throw new VariableNotInitializedException(var.getId());

            }
        }

        value.setType(type);
        return value;

    }}

Operation OPERATION():
    {
        Value v1 = null, v2 = null;
        Token tokenOp = null, tokenBop = null, tokenCop = null;
    }{(
        v1 = VALUE() (tokenOp = <OP> | tokenBop = <BOP> | tokenCop = <COP>) (v2 = OPERATION() | v2 = VALUE())
    ){

        Operation op = null;
        if (tokenOp != null) {
            String strOp = tokenOp.toString();
            switch(strOp) {
                case "+":
                    if (v1.getType() == Type.STRING) op = new ConcatOperation();
                    else op = new SumOperation(); break;
                case "-": op = new MinusOperation(); break;
                case "*": op = new TimesOperation(); break;
                case "/": op = new DivideOperation(); break;
                case "%": op = new ModOperation(); break;
            }
        } else if (tokenCop != null) {
            String strOp = tokenCop.toString();
            switch(strOp) {
                case ">": op = new GreaterOperation(); break;
                case "<": op = new SmallerOperation(); break;
                case ">=": op = new GreaterEqualsOperation(); break;
                case "<=": op = new SmallerEqualsOperation(); break;
                case "==": op = new EqualsOperation(); break;
                case "!=": op = new DifferentOperation(); break;
             }
        } else if (tokenBop != null) {
            String strOp = tokenBop.toString();
            switch(strOp) {
                case "&&": op = new AndOperation(); break;
                case "||": op = new OrOperation(); break;
                case "!": op = new NotOperation(); break;
            }
        }

        op.setOperands(v1, v2);
        return op;

    }}



