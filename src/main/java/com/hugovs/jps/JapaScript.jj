options {
    LOOKAHEAD=8;
    UNICODE_INPUT=true;
}

PARSER_BEGIN(Lexer)

package com.hugovs.jps;

import java.util.List;
import java.util.ArrayList;
import java.util.Stack;
import java.io.*;
import com.hugovs.jps.structure.semanthic.*;
import com.hugovs.jps.structure.semanthic.command.*;
import com.hugovs.jps.structure.semanthic.operation.*;
import com.hugovs.jps.structure.semanthic.operation.bool.*;
import com.hugovs.jps.structure.semanthic.operation.compare.*;
import com.hugovs.jps.structure.semanthic.operation.integer.*;
import com.hugovs.jps.structure.semanthic.operation.string.*;
import com.hugovs.jps.structure.exception.*;

public class Lexer {

    public static Block program = new Block();
    public static int blockCount = 0;
    public static Stack<Block> stack = new Stack<Block>();

    public static void main(String[] args) {
        try {
            new Lexer(new java.io.FileInputStream(args[0])).S();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}

PARSER_END(Lexer)

SKIP: {" " | "\t" | "\n" | "\r" | < "//" (~["\r", "\n"])* > }

TOKEN: {
      <LPAREN: "(">
    | <RPAREN: ")">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <LBRACK: "[">
    | <RBRACK: "]">
    | <COMMA: ",">
    | <COLON: ":">
    | <SEMICOLON: ";">
    | <ATTR: "=">
    | <OP: "+" | "-" | "/" | "*" | "%">
    | <COP: "<" | ">" | "<=" | ">=" | "==" | "!=">
    | <BOP: "!" | "&&" | "||" >

    // Restricted
    | <DEF: "def">
    | <VAR: "var">
    | <TYPE: "int" | "bool" | "string" >
    | <BOOL: "true" | "false">

    // Commands
    | <CMD_IF: "if">
    | <CMD_ELSE: "else">
    | <CMD_FOR: "for">
    | <CMD_WHILE: "while">
    | <CMD_READ: "read">
    | <CMD_WRITE: "write">
    | <CMD_STOP: "stop">
    | <CMD_SKIP: "skip">
    | <CMD_RETURN: "return">

    // Util
    | <ID: <CHAR> (<CHAR> | <NUM>)* >

    // Primitives
    | <STR: ["\""] (<CHAR> | <NUM> | " " | <SPECIAL_CHAR>)* ["\""]>
    | <CHAR: ["a"-"z"] | ["A"-"Z"] | ["_"]>
    | <NUM: (["0"-"9"])+>
    | <SPECIAL_CHAR: "!" | ["#"-"~"] >
}

// Regra inicial
void S():
    {

    }{(
        PROGRAM() <EOF>
    ){

    }}

// Regra do programa
void PROGRAM():
    {
        Block program = Lexer.program;
        Block block = null;
    }{(
        block = ROOT_BLOCK()
    ){
        program = block;

        Identifier main = block.getIdentifier("main");
        if (!(main instanceof Subprogram))
            throw new IncompatibleTypeException();

    }}

// Regra de Sub-Programa
Subprogram SUB_PROGRAM():
    {
        Subprogram subprogram = new Subprogram();
        Block block, parent = Lexer.stack.peek();
        Token typeToken = null, idToken = null;
        List<Variable> parameters = new ArrayList<Variable>();
    }{(
        <DEF> idToken = <ID> <LPAREN> (parameters = PARAMETERS())? <RPAREN> (<COLON> typeToken = <TYPE>)? block = BLOCK(parameters)
    ){

        String id = idToken.toString();
        Type returnType = typeToken == null ? Type.VOID : Type.valueOf(typeToken.toString().toUpperCase());

        subprogram.setId(id);
        subprogram.setReturnType(returnType);
        subprogram.setBlock(block);
        subprogram.setParameters(parameters);

        block.getParent().addIdentifier(subprogram);

        for (Command cmd : block.getCommands())
            if (cmd instanceof ReturnCommand) {
                ReturnCommand returnCmd = (ReturnCommand)cmd;
                if (returnCmd.getExpression().getType() != subprogram.getReturnType())
                    throw new IncompatibleTypeException(returnCmd.getExpression().getType(), subprogram.getReturnType());
            }

        return subprogram;

    }}

// Bloco inicial do programa
Block ROOT_BLOCK():
    {
        Block block = new Block();
        Lexer.stack.push(block);
        List<Variable> varList = null;
    }{(
        (varList = VAR_SECTION() { block.addAll(varList); })? (STATEMENT())?
    ){

        System.out.println("Identifiers found in block " + Lexer.blockCount + ": ");
        for (Identifier i : block.getIdentifiers().values())
            System.out.println("  " + i.toString());

        Lexer.stack.pop();
        return block;
    }}

// Blocos internos no programa
Block BLOCK(List<Variable> parameters):
    {
        Lexer.blockCount++;
        Block block = new Block();
        block.setParent(Lexer.stack.peek());
        block.addAll(parameters);
        Lexer.stack.push(block);
        List<Variable> varList = null;
    }{(
        <LBRACE> (varList = VAR_SECTION() {block.addAll(varList);} )? (STATEMENT())? <RBRACE>
    ){

        Lexer.stack.pop();
        return block;
    }}

//void SUB_PROGRAM_CALL(): {} { }

void STATEMENT():
    {
        Block block = Lexer.stack.peek();
        Subprogram sub = null;
        Command cmd = null;
    }{(
        (sub = SUB_PROGRAM() | cmd = CMD()) (STATEMENT())?//|   SUB_PROGRAM_CALL()
    ){
        if (cmd != null)
            block.addCommand(cmd);
    }}

// Command syntax
Command CMD():
    {
        Command cmd = null;
    }{(
        cmd = CMD_RETURN() | cmd = CMD_WHILE() | cmd = CMD_SKIP() | cmd = CMD_STOP() | cmd = CMD_WRITE() | cmd = CMD_READ() |
        cmd = CMD_IF() | (cmd = CMD_ATTRIB() <SEMICOLON>) | cmd = CMD_FOR()
        | cmd = CMD_SUB()
    ){
        return cmd;
    }}

Command CMD_RETURN():
    {
        ReturnCommand cmd = new ReturnCommand();
        Expression exp = new Expression();
        exp.setType(Type.VOID);
    }{(
        <CMD_RETURN> (exp = EXPRESSION())? <SEMICOLON>
    ){
        cmd.setExpression(exp);
        return cmd;
    }}

Command CMD_SUB():
    {
        SubCommand cmd = new SubCommand();
        Block block = Lexer.stack.peek();
        Token idToken = null;
        List<Expression> arguments = new ArrayList<Expression>();
        Expression exp = null;
    }{(
        idToken = <ID> <LPAREN> (exp = EXPRESSION() {arguments.add(exp);} (<COMMA> exp = EXPRESSION() {arguments.add(exp);})* )? <RPAREN> <SEMICOLON>
    ){

        Identifier id = block.getIdentifier(idToken.toString());
        if (!(id instanceof Subprogram))
            throw new IncompatibleTypeException("Expected: Subprogram. Found: Variable");
        Subprogram sub = (Subprogram)id;

        if (sub.getParameters().size() != arguments.size())
            throw new RuntimeException("Subprogram " + sub.getId() + " has " + sub.getParameters().size() + " parameters. Found: " + arguments.size() + " arguments.");
        for (int i = 0; i < sub.getParameters().size(); i++) {
            Variable var = sub.getParameters().get(i);
            Expression aExp = arguments.get(i);
            if (var.getType() != aExp.getType())
                throw new IncompatibleTypeException("Incompatible type in argument " + i + ". Expected: " + var.getType() + ". Found: " + aExp.getType());
        }

        cmd.setSubprogram(sub);
        cmd.setArguments(arguments);

        return cmd;
    }}

Command CMD_WHILE():
    {
        WhileCommand cmd = new WhileCommand();
        Expression exp = null;
        Block block = null;
    }{(
        <CMD_WHILE> <LPAREN> exp = EXPRESSION() <RPAREN> block = BLOCK(new ArrayList())
    ){

        if (exp.getType() != Type.BOOL)
            throw new IncompatibleTypeException(Type.BOOL, exp.getType());

        cmd.setExpression(exp);
        cmd.setBlock(block);
        return cmd;
    }}

Command CMD_IF():
    {
        IfCommand cmd = new IfCommand();
        Command elseCmd = null;
        Expression exp = null;
        Block block = null;
    }{(
        <CMD_IF> <LPAREN> exp = EXPRESSION() <RPAREN> block = BLOCK(new ArrayList()) (elseCmd = CMD_ELSE())?
    ){

        if (exp.getType() != Type.BOOL)
            throw new IncompatibleTypeException(Type.BOOL, exp.getType());

        cmd.setExpression(exp);
        cmd.setElseCommand((ElseCommand)elseCmd);
        cmd.setBlock(block);

        return cmd;
    }}

Command CMD_ELSE():
    {
        ElseCommand cmd = new ElseCommand();
        Command ifCmd = null;
        Block block = null;
    }{(
        <CMD_ELSE> (ifCmd = CMD_IF() | block = BLOCK(new ArrayList()))
    ){
        cmd.setBlock(block);
        cmd.setIfCommand((IfCommand)ifCmd);
        return cmd;
    }}
Command CMD_FOR():
    {
        ForCommand cmd = new ForCommand();
    }{(
        <CMD_FOR> <LPAREN> (CMD_ATTRIB())? (<COMMA> CMD_ATTRIB())* <SEMICOLON> EXPRESSION() <SEMICOLON> (CMD_ATTRIB())? (<COMMA> CMD_ATTRIB())* <RPAREN> BLOCK(new ArrayList())
    ){
        return cmd;
    }}
Command CMD_READ():
    {
        ReadCommand cmd = new ReadCommand();
        Token idToken = null;
        Expression arrayExp = null;
    }{(
        <CMD_READ> idToken = <ID> (<LBRACK> arrayExp = EXPRESSION() <RBRACK>)? <SEMICOLON>
    ){

        String idStr = idToken.toString();
        Block block = Lexer.stack.peek();

        Identifier id = block.getIdentifier(idStr);

        if (!(id instanceof Variable))
            throw new IncompatibleTypeException("Expected: Variable. Found: Subprogram");
        Variable var = (Variable)id;
        if (arrayExp != null && !var.isArray())
            throw new IncompatibleTypeException("Variable " + var.getId() + " is not and array");

        var.setValue(new Value(var.getType(), null));
        cmd.setVariable(var);
        return cmd;
    }}
Command CMD_WRITE():
    {
        WriteCommand cmd = new WriteCommand();
        List<Expression> expList = new ArrayList<Expression>();
        Expression exp = null;
    }{(
        <CMD_WRITE> (exp = EXPRESSION() {expList.add(exp);}) (<COMMA> exp = EXPRESSION() {expList.add(exp);})* <SEMICOLON>
    ){
        cmd.setExpressions(expList);
        return cmd;
    }}
Command CMD_STOP():
    {
        StopCommand cmd = new StopCommand();
    }{(
        <CMD_STOP> <SEMICOLON>
    ){
        return cmd;
    }}
Command CMD_SKIP():
    {
        SkipCommand cmd = new SkipCommand();
    }{(
        <CMD_SKIP> <SEMICOLON>
    ){
        return cmd;
    }}

Command CMD_ATTRIB():
    {
        AttributionCommand cmd = new AttributionCommand();
        Block block = Lexer.stack.peek();
        Expression arrayExp = null, exp = null;
        Token idToken = null;
    }{(
        (idToken = <ID> (<LBRACK> arrayExp = EXPRESSION() <RBRACK>)? | <ID>) (<OP>)? <ATTR> exp = EXPRESSION()
    ){

        String idStr = idToken.toString();
        Identifier id = block.getIdentifier(idStr);

        if (!(id instanceof Variable))
            throw new IncompatibleTypeException("Expected: Variable. Found: Subprogram");
        Variable var = (Variable)id;

        if (var.getType() != exp.getType())
            throw new IncompatibleTypeException(var.getType(), exp.getType());

        var.setValue(exp);

        return cmd;
    }}

Expression EXPRESSION():
    {
        Expression exp = new Expression();
        Value v = null;
        Operation op = null;
    }{(
        op = OPERATION() | v = VALUE()
    ){

        if (v != null) {
            exp.setSingleton(true);
            exp.setType(v.getType());
            exp.setValue(v);
        } else if (op != null) {
            exp.setSingleton(false);
            exp.setType(op.getType());
            exp.addOperation(op);
        }

        return exp;

    }}

// Regra base para declaração de umaou mais variáveis
List<Variable> VAR():
    {
        List<Variable> varList;
        Token typeToken;
    }{(
        <VAR> varList = VAR_LIST() <COLON> typeToken = <TYPE>
    ){
        Type type = Type.valueOf(typeToken.toString().toUpperCase());
        Util.updateVariableTypes(varList, type);

        return varList;
    }}

// Lista de variáveis
List<Variable> VAR_LIST():
    {
        List<Variable> varList = new ArrayList<Variable>(), ret = new ArrayList<Variable>();
        Variable var = new Variable();
        Token idToken;
        Expression arrayExp = null, attrExp = null;
        List<Value> list = new ArrayList<Value>();
        boolean isArray = false;
    }{(

        idToken = <ID> <LBRACK> arrayExp = EXPRESSION() <RBRACK> (<ATTR> list = ARRAY_INIT())? (<COMMA> ret = VAR_LIST())? { isArray = true; }
    |   idToken = <ID> (<ATTR> attrExp = EXPRESSION())? (<COMMA> ret = VAR_LIST())?

    ){
        String id = idToken.toString();

        if (arrayExp != null && arrayExp.getType() != Type.INT)
            throw new IncompatibleTypeException(Type.INT, arrayExp.getType());

        if (attrExp != null && arrayExp == null)
            var.setValue(attrExp);
        else if (arrayExp != null) {
            var.setValues(list);
        }

        var.setId(id);
        var.setArray(isArray);
        var.setLength(Integer.MAX_VALUE);
        varList.addAll(ret);
        varList.add(var);
        return varList;
    }}

List<Value> ARRAY_INIT():
    {
        List<Value> list = new ArrayList<Value>();
        Expression exp = null;
    }{(
        <LBRACE> (exp = EXPRESSION() {list.add(exp);} (<COMMA> exp = EXPRESSION() {list.add(exp);})* )? <RBRACE>
    ){
        return list;
    }}

// Seção de variáveis separadas por ponto e vírgula
List<Variable> VAR_SECTION():
    {
        List<Variable> varList = null, ret = null;
    }{(
        (varList = VAR() <SEMICOLON> (ret = VAR_SECTION())?)
    ){
        if (ret != null)
            varList.addAll(ret);
        return varList;
    }}

// Regra de definição de parâmetros de sub-programa
List<Variable> PARAMETERS():
        {
            List<Variable> varList, v2 = null;
            Token typeToken;
        }{(
            varList = PARAM_LIST() <COLON> typeToken = <TYPE> (<SEMICOLON> v2 = PARAMETERS())?
        ){

            Type type = Type.valueOf(typeToken.toString().toUpperCase());
            Util.updateVariableTypes(varList, type);

            if (v2 != null)
                varList.addAll(v2);

            return varList;
        }}

List<Variable> PARAM_LIST():
    {
        List<Variable> varList = new ArrayList<Variable>(), ret = new ArrayList<Variable>();
        Variable var = new Variable();
        Token idToken;
        boolean isArray = false;
    }{(

        idToken = <ID> <LBRACK> <RBRACK> (<COMMA> ret = PARAM_LIST())? { isArray = true; }
    |   idToken = <ID> (<COMMA> ret = PARAM_LIST())?

    ){
        String id = idToken.toString();

        var.setId(id);
        var.setArray(isArray);
        var.setLength(Integer.MAX_VALUE);
        var.setValue(new Value());
        var.setParameter(true);
        varList.addAll(ret);
        varList.add(var);
        return varList;
    }}

Value VALUE():
    {
        Token idToken = null, numToken = null, boolToken = null, strToken = null;
        Block block = Lexer.stack.peek();
        Value value = new Value();
        Expression arrayExp = null;
    }{(
        (numToken = <NUM> | boolToken = <BOOL> | strToken = <STR> | idToken = <ID> <LBRACK> arrayExp = EXPRESSION() <RBRACK> | idToken = <ID>) |
        (<LPAREN> (numToken = <NUM> | boolToken = <BOOL> | strToken = <STR> | idToken = <ID> <LBRACK> numToken = <NUM> <RBRACK> | idToken = <ID>) <RPAREN>)
    ){

        Type type = null;

        Integer num = null;
        if (numToken != null && idToken == null) {
            num = Integer.valueOf(numToken.toString());
            value.setValue(num);
            type = Type.INT;
        }

        Boolean bool = null;
        if (boolToken != null) {
            bool = Boolean.valueOf(boolToken.toString());
            value.setValue(bool);
            type = Type.BOOL;
        }

        String str = null;
        if (strToken != null) {
            str = strToken.toString();
            value.setValue(str);
            type = Type.STRING;
        }

        Identifier id = null;
        if (idToken != null) {
            id = block.getIdentifier(idToken.toString());
            if (id instanceof Variable) {
                Variable var = ((Variable) id);
                type = var.getType();
                if (arrayExp != null) {
                    if (!var.isArray()) throw new IncompatibleTypeException("Variable " + id + " is not an array");
                } else if (var.isArray()) {
                    //throw new IncompatibleTypeException("Variable " + id + " is an array");
                }

                if (!var.isInitialized() && block.hasIdentifier(var.getId()))
                    throw new VariableNotInitializedException(var.getId());

            }
        }

        value.setType(type);
        return value;

    }}

Operation OPERATION():
    {
        Value v1 = null, v2 = null;
        Token tokenOp = null, tokenBop = null, tokenCop = null;
    }{(
        (v1 = VALUE() (tokenOp = <OP> | tokenBop = <BOP> | tokenCop = <COP>) (v2 = OPERATION() | v2 = VALUE())) |
        (<LPAREN> v1 = VALUE() (tokenOp = <OP> | tokenBop = <BOP> | tokenCop = <COP>) (v2 = OPERATION() | v2 = VALUE()) <RPAREN>)
    ){

        Operation op = Operation.getForToken(tokenOp, tokenCop, tokenBop, v1);
        op.setOperands(v1, v2);
        return op;

    }}



